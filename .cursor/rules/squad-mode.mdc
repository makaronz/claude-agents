---
description: Squad Mode multi-agent orchestration patterns and best practices
---

# Squad Mode Implementation Patterns

## Architecture Overview

Squad Mode enables multi-agent collaboration where specialist agents analyze creative briefs in parallel and provide comprehensive strategies.

### Key Components
- **SquadContext**: Manages squad mode state and analysis progress
- **Specialist Agents**: Individual agents with specific expertise
- **Analysis Orchestration**: Parallel execution of specialist analysis
- **Synthesis**: Creative Director consolidates results into actionable plans

## Context Structure

### SquadContext Implementation
```typescript
interface SquadState {
  isSquadMode: boolean;
  currentAnalysis: {
    briefId: string | null;
    brief: string | null;
    isRunning: boolean;
    progress: Record<string, number>; // specialistId: progress (0-100)
    results: SpecialistResult[];
    synthesis: SquadSynthesis | null;
  };
}

type SquadAction =
  | { type: 'TOGGLE_SQUAD_MODE' }
  | { type: 'START_ANALYSIS'; payload: { briefId: string; brief: string } }
  | { type: 'UPDATE_PROGRESS'; payload: { specialist: string; progress: number; status: string } }
  | { type: 'ADD_RESULT'; payload: SpecialistResult }
  | { type: 'SET_SYNTHESIS'; payload: SquadSynthesis }
  | { type: 'RESET_ANALYSIS' };
```

### Specialist Types
```typescript
interface SpecialistResult {
  specialistId: string;
  specialistName: string;
  analysis: string;
  recommendations: string[];
  confidence: number; // 0-10
  timestamp: string;
}

interface SquadSynthesis {
  briefId: string;
  overallScore: number; // 0-10
  synthesis: string;
  actionPlan: string[];
  keyInsights: string[];
  risks: string[];
  opportunities: string[];
}
```

## Specialist Agent Integration

### Agent Registration Pattern
```typescript
const SPECIALISTS = [
  { id: 'creative-director', name: 'Creative Director', icon: 'ðŸŽ¨' },
  { id: 'strategist', name: 'Strategic Planner', icon: 'ðŸ§ ' },
  { id: 'copywriter', name: 'Copywriter', icon: 'âœï¸' },
  { id: 'art-director', name: 'Art Director', icon: 'ðŸŽ­' },
  { id: 'media-planner', name: 'Media Planner', icon: 'ðŸ“Š' },
  { id: 'account-manager', name: 'Account Manager', icon: 'ðŸ‘¥' },
];

// Specialist analysis execution
const executeSpecialistAnalysis = async (specialistId: string, brief: string) => {
  const specialist = SPECIALISTS.find(s => s.id === specialistId);
  if (!specialist) throw new Error(`Specialist ${specialistId} not found`);
  
  // Simulate analysis progress
  for (let progress = 0; progress <= 100; progress += 20) {
    updateProgress({ specialist: specialistId, progress, status: 'analyzing' });
    await new Promise(resolve => setTimeout(resolve, 500));
  }
  
  // Generate analysis result
  const result: SpecialistResult = {
    specialistId,
    specialistName: specialist.name,
    analysis: `Analysis from ${specialist.name}`,
    recommendations: ['Recommendation 1', 'Recommendation 2'],
    confidence: Math.floor(Math.random() * 5) + 6, // 6-10
    timestamp: new Date().toISOString(),
  };
  
  addResult(result);
};
```

### Parallel Analysis Execution
```typescript
const runSquadAnalysis = async (brief: string) => {
  const briefId = `brief-${Date.now()}`;
  
  // Start analysis
  startAnalysis({ briefId, brief });
  
  // Execute all specialists in parallel
  const analysisPromises = SPECIALISTS.map(specialist => 
    executeSpecialistAnalysis(specialist.id, brief)
  );
  
  try {
    await Promise.all(analysisPromises);
    
    // Generate synthesis after all specialists complete
    const synthesis = await generateSynthesis(briefId, brief);
    setSynthesis(synthesis);
    
  } catch (error) {
    console.error('Squad analysis failed:', error);
  }
};
```

## UI Components

### Squad Mode Toggle
```typescript
interface SquadModeToggleProps {
  isSquadMode: boolean;
  onToggle: (enabled: boolean) => void;
  specialistCount?: number;
}

export const SquadModeToggle: React.FC<SquadModeToggleProps> = ({
  isSquadMode,
  onToggle,
  specialistCount = 6,
}) => {
  return (
    <div className="flex items-center space-x-3">
      <span className="text-sm font-medium text-gray-700">
        Squad Mode
      </span>
      <button
        onClick={() => onToggle(!isSquadMode)}
        className={cn(
          "relative inline-flex h-6 w-11 items-center rounded-full transition-colors",
          isSquadMode ? "bg-gradient-to-r from-purple-600 to-blue-600" : "bg-gray-200"
        )}
      >
        <span
          className={cn(
            "inline-block h-4 w-4 transform rounded-full bg-white transition-transform",
            isSquadMode ? "translate-x-6" : "translate-x-1"
          )}
        />
      </button>
      <span className="text-xs text-gray-500">
        {specialistCount} specialists
      </span>
    </div>
  );
};
```

### Specialist Progress Cards
```typescript
export const SpecialistCards: React.FC<{
  analysisProgress: Record<string, number>;
  results: SpecialistResult[];
  isAnalyzing: boolean;
}> = ({ analysisProgress, results, isAnalyzing }) => {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
      {SPECIALISTS.map(specialist => {
        const progress = analysisProgress[specialist.id] || 0;
        const result = results.find(r => r.specialistId === specialist.id);
        
        return (
          <Card key={specialist.id} variant="squad">
            <CardHeader>
              <CardTitle className="flex items-center space-x-2">
                <span className="text-xl">{specialist.icon}</span>
                <span>{specialist.name}</span>
              </CardTitle>
            </CardHeader>
            <CardContent>
              {isAnalyzing && progress < 100 ? (
                <div>
                  <div className="flex justify-between text-sm mb-2">
                    <span>Analyzing...</span>
                    <span>{progress}%</span>
                  </div>
                  <div className="w-full bg-gray-200 rounded-full h-2">
                    <div 
                      className="bg-gradient-to-r from-purple-600 to-blue-600 h-2 rounded-full transition-all duration-300"
                      style={{ width: `${progress}%` }}
                    />
                  </div>
                </div>
              ) : result ? (
                <div className="space-y-2">
                  <div className="text-sm text-gray-600">
                    Confidence: {result.confidence}/10
                  </div>
                  <p className="text-sm">{result.analysis}</p>
                  <div className="text-xs text-gray-500">
                    {new Date(result.timestamp).toLocaleTimeString()}
                  </div>
                </div>
              ) : (
                <div className="text-sm text-gray-500">
                  Waiting to start...
                </div>
              )}
            </CardContent>
          </Card>
        );
      })}
    </div>
  );
};
```

## Integration Patterns

### WebSocket Integration
```typescript
// Real-time updates for squad analysis
const useSquadWebSocket = () => {
  const { updateProgress, addResult, setSynthesis } = useSquadContext();
  
  useEffect(() => {
    if (!socket) return;
    
    // Listen for specialist progress updates
    socket.on('squad:analysis:progress', ({ briefId, specialist, progress }) => {
      updateProgress({ briefId, specialist, progress, status: 'analyzing' });
    });
    
    // Listen for specialist completion
    socket.on('squad:specialist:completed', (result) => {
      addResult(result);
    });
    
    // Listen for synthesis completion
    socket.on('squad:synthesis:completed', ({ briefId, synthesis }) => {
      setSynthesis(synthesis);
    });
    
    return () => {
      socket.off('squad:analysis:progress');
      socket.off('squad:specialist:completed');
      socket.off('squad:synthesis:completed');
    };
  }, [updateProgress, addResult, setSynthesis]);
};
```

### Project Integration
```typescript
// Create project from squad analysis
const createProjectFromAnalysis = (synthesis: SquadSynthesis) => {
  const project: CreateProjectRequest = {
    name: `Campaign: ${synthesis.keyInsights[0]}`,
    description: synthesis.synthesis,
    status: 'Planning',
    priority: synthesis.overallScore >= 8 ? 'High' : 'Medium',
    budget: 100000, // Default budget
    deadline: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(), // 30 days
    teamMembers: [], // Will be populated based on analysis
  };
  
  return project;
};
```

## Error Handling

### Analysis Error Recovery
```typescript
const handleAnalysisError = (error: Error, specialistId: string) => {
  console.error(`Specialist ${specialistId} analysis failed:`, error);
  
  // Update progress to show error state
  updateProgress({ 
    specialist: specialistId, 
    progress: 0, 
    status: 'error' 
  });
  
  // Add error result
  const errorResult: SpecialistResult = {
    specialistId,
    specialistName: SPECIALISTS.find(s => s.id === specialistId)?.name || 'Unknown',
    analysis: `Analysis failed: ${error.message}`,
    recommendations: ['Please try again or contact support'],
    confidence: 0,
    timestamp: new Date().toISOString(),
  };
  
  addResult(errorResult);
};
```

## Performance Considerations

### Analysis Optimization
- Use `Promise.all()` for parallel specialist execution
- Implement progress tracking for long-running analyses
- Cache analysis results to avoid re-computation
- Use Web Workers for computationally intensive analysis

### Memory Management
- Clear analysis results when starting new analysis
- Limit result history to prevent memory leaks
- Use cleanup functions in useEffect hooks
- Implement proper error boundaries for specialist failures