---
globs: *.tsx,*.ts
description: React component development patterns and best practices
---

# React Component Development Patterns

## Component Structure

### File Organization
```
components/
├── common/              # Reusable UI components
│   ├── Button/
│   │   ├── Button.tsx
│   │   └── index.ts
│   ├── Input/
│   └── Modal/
├── projects/            # Feature-specific components
│   ├── ProjectForm/
│   └── ProjectList/
└── layout/             # Layout components
    ├── Header/
    ├── Sidebar/
    └── Layout/
```

### Component Template
```typescript
import React from 'react';
import { cn } from '@/utils/helpers';

interface ComponentProps {
  className?: string;
  children?: React.ReactNode;
  // Other props with proper typing
}

export const Component: React.FC<ComponentProps> = ({
  className,
  children,
  ...props
}) => {
  return (
    <div 
      className={cn("base-classes", className)}
      {...props}
    >
      {children}
    </div>
  );
};

Component.displayName = 'Component';
```

## Context Integration

### Using Context in Components
```typescript
import { useProjectContext } from '@/context';

const ProjectComponent = () => {
  const { state, addProject, updateProject } = useProjectContext();
  
  // Handle context actions
  const handleAddProject = (project: Project) => {
    try {
      addProject(project);
    } catch (error) {
      console.error('Failed to add project:', error);
    }
  };

  return (
    <div>
      {/* Component JSX */}
    </div>
  );
};
```

### Error Handling for Context
```typescript
// Safe context usage with fallbacks
const useSafeContext = () => {
  try {
    return useProjectContext();
  } catch (error) {
    // Return default values or handle gracefully
    return {
      state: initialState,
      addProject: () => {},
      updateProject: () => {},
    };
  }
};
```

## Form Components

### Controlled Components
```typescript
interface FormFieldProps {
  label: string;
  value: string;
  onChange: (value: string) => void;
  error?: string;
  required?: boolean;
}

export const FormField: React.FC<FormFieldProps> = ({
  label,
  value,
  onChange,
  error,
  required = false,
}) => {
  return (
    <div>
      <label className="block text-sm font-medium text-gray-700 mb-1">
        {label}
        {required && <span className="text-red-500 ml-1">*</span>}
      </label>
      <input
        value={value}
        onChange={(e) => onChange(e.target.value)}
        className={cn(
          "mt-1 block w-full px-3 py-2 border rounded-md",
          error ? "border-red-500" : "border-gray-300",
          "focus:outline-none focus:ring-primary-500 focus:border-primary-500"
        )}
      />
      {error && <p className="mt-2 text-sm text-red-600">{error}</p>}
    </div>
  );
};
```

### Form Validation Integration
```typescript
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';

const FormComponent = () => {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
    watch,
    setValue,
  } = useForm<FormData>({
    resolver: zodResolver(validationSchema),
  });

  const onSubmit = async (data: FormData) => {
    try {
      // Handle form submission
      console.log('Form data:', data);
    } catch (error) {
      console.error('Form submission error:', error);
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {/* Form fields using register() */}
    </form>
  );
};
```

## State Management

### Local State Patterns
```typescript
const Component = () => {
  // Simple state
  const [isOpen, setIsOpen] = useState(false);
  
  // Complex state with useReducer
  const [state, dispatch] = useReducer(reducer, initialState);
  
  // Derived state
  const filteredItems = useMemo(() => 
    items.filter(item => item.status === 'active'),
    [items]
  );

  // Effects
  useEffect(() => {
    // Side effects
  }, [dependency]);

  return <div>{/* Component JSX */}</div>;
};
```

### Context State Updates
```typescript
const Component = () => {
  const { state, dispatch } = useProjectContext();
  
  // Batch updates
  const handleBatchUpdate = () => {
    dispatch({ type: 'BATCH_START' });
    dispatch({ type: 'UPDATE_ITEM_1', payload: data1 });
    dispatch({ type: 'UPDATE_ITEM_2', payload: data2 });
    dispatch({ type: 'BATCH_END' });
  };

  return <div>{/* Component JSX */}</div>;
};
```

## Performance Optimization

### Memoization Patterns
```typescript
import React, { memo, useMemo, useCallback } from 'react';

// Component memoization
export const ExpensiveComponent = memo<Props>(({ data, onUpdate }) => {
  // Expensive calculations
  const processedData = useMemo(() => 
    data.map(item => expensiveCalculation(item)),
    [data]
  );

  // Stable callbacks
  const handleUpdate = useCallback((id: string) => {
    onUpdate(id);
  }, [onUpdate]);

  return <div>{/* Component JSX */}</div>;
});

ExpensiveComponent.displayName = 'ExpensiveComponent';
```

### Avoiding Unnecessary Re-renders
```typescript
// Use React.memo for expensive components
const ProjectCard = memo<ProjectCardProps>(({ project, onEdit }) => {
  return (
    <div className="project-card">
      {/* Card content */}
    </div>
  );
});

// Use useMemo for expensive calculations
const Component = ({ items }) => {
  const sortedItems = useMemo(() => 
    items.sort((a, b) => a.name.localeCompare(b.name)),
    [items]
  );

  return <div>{/* Component JSX */}</div>;
};
```

## Error Boundaries

### Component Error Handling
```typescript
import React, { Component, ReactNode } from 'react';

interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends Component<
  { children: ReactNode },
  ErrorBoundaryState
> {
  constructor(props: { children: ReactNode }) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="error-boundary">
          <h2>Something went wrong.</h2>
          <details>
            {this.state.error?.message}
          </details>
        </div>
      );
    }

    return this.props.children;
  }
}
```

## Accessibility

### ARIA and Semantic HTML
```typescript
const AccessibleComponent = () => {
  return (
    <div>
      {/* Use semantic HTML */}
      <main role="main">
        <section aria-labelledby="section-heading">
          <h2 id="section-heading">Section Title</h2>
          
          {/* Form with proper labels */}
          <form>
            <label htmlFor="input-id">Input Label</label>
            <input 
              id="input-id"
              aria-describedby="input-help"
              aria-invalid={hasError}
            />
            {hasError && (
              <div id="input-help" role="alert">
                Error message
              </div>
            )}
          </form>
        </section>
      </main>
    </div>
  );
};
```

### Keyboard Navigation
```typescript
const KeyboardNavigableComponent = () => {
  const handleKeyDown = (e: React.KeyboardEvent) => {
    switch (e.key) {
      case 'Enter':
      case ' ':
        // Handle activation
        break;
      case 'Escape':
        // Handle close
        break;
    }
  };

  return (
    <div
      tabIndex={0}
      onKeyDown={handleKeyDown}
      role="button"
      aria-label="Action description"
    >
      Interactive content
    </div>
  );
};
```

## Testing Considerations

### Component Testing Patterns
```typescript
// Test component behavior, not implementation
describe('ProjectForm', () => {
  it('should submit form with valid data', async () => {
    const mockSubmit = jest.fn();
    render(<ProjectForm onSubmit={mockSubmit} />);
    
    await user.type(screen.getByLabelText(/project name/i), 'Test Project');
    await user.click(screen.getByRole('button', { name: /submit/i }));
    
    expect(mockSubmit).toHaveBeenCalledWith({
      name: 'Test Project',
      // ... other expected data
    });
  });
});
```