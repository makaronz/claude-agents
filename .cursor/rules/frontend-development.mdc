---
alwaysApply: true
description: Frontend development patterns and best practices for React/TypeScript applications
---

# Frontend Development Patterns

## React Context API State Management

When working with state management in React applications, prefer React Context API with useReducer over Redux Toolkit for simpler applications.

### Context Provider Pattern
```typescript
// Create context with proper typing
interface ContextType {
  state: StateType;
  dispatch: React.Dispatch<ActionType>;
  // Action creators
  action1: () => void;
  action2: (payload: any) => void;
}

const Context = createContext<ContextType | undefined>(undefined);

// Provider component
export const Provider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [state, dispatch] = useReducer(reducer, initialState);
  
  // Action creators - keep simple, avoid useCallback unless necessary
  const action1 = () => dispatch({ type: 'ACTION_1' });
  const action2 = (payload: any) => dispatch({ type: 'ACTION_2', payload });
  
  const value = useMemo(() => ({
    state,
    dispatch,
    action1,
    action2,
  }), [state]); // Only include state in dependencies
  
  return <Context.Provider value={value}>{children}</Context.Provider>;
};

// Custom hook with error handling
export const useContext = (): ContextType => {
  const context = useContext(Context);
  if (context === undefined) {
    throw new Error('useContext must be used within a Provider');
  }
  return context;
};
```

### Avoiding Infinite Loops
- Use `useRef` for one-time effects: `const hasLoaded = useRef(false);`
- Keep `useMemo` dependencies minimal: only include actual dependencies
- Avoid `useCallback` for simple action creators unless performance is critical
- Use empty dependency arrays `[]` for effects that should only run once

## Form Handling with React Hook Form

Always use React Hook Form with Zod validation for complex forms:

```typescript
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';

// Define validation schema
const schema = z.object({
  name: z.string().min(1, 'Name is required'),
  email: z.string().email('Invalid email'),
});

type FormData = z.infer<typeof schema>;

const FormComponent = () => {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<FormData>({
    resolver: zodResolver(schema),
  });

  const onSubmit = async (data: FormData) => {
    try {
      // Handle submission
      console.log(data);
    } catch (error) {
      console.error('Submission error:', error);
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {/* Form fields */}
    </form>
  );
};
```

## Component Structure

### File Organization
```
src/
├── components/
│   ├── common/           # Reusable UI components
│   ├── projects/         # Feature-specific components
│   └── layout/          # Layout components
├── context/             # React Context providers
├── hooks/              # Custom hooks
├── pages/              # Page components
├── types/              # TypeScript type definitions
└── utils/              # Utility functions
```

### Component Patterns
- Use TypeScript interfaces for props
- Implement proper error boundaries
- Use semantic HTML elements
- Follow accessibility guidelines (ARIA labels, keyboard navigation)
- Use Tailwind CSS for styling with custom design system

## Error Handling

### Context Error Boundaries
```typescript
// Always wrap context usage in try-catch for hooks
try {
  const contextValue = useSomeContext();
  // Use context
} catch (error) {
  // Handle context not available
  return <div>Context not available</div>;
}
```

### Form Validation
- Use Zod schemas for runtime validation
- Display validation errors clearly to users
- Handle async validation properly
- Provide helpful error messages

## Performance Optimization

- Use `React.memo` sparingly, only for expensive components
- Implement proper dependency arrays in hooks
- Avoid unnecessary re-renders by keeping context values stable
- Use `useMemo` and `useCallback` judiciously

## Testing Considerations

- Test components in isolation
- Mock external dependencies
- Test error states and edge cases
- Use Playwright for E2E testing
- Test form validation and submission flows