---
globs: agents/**/sub-agents/**/*.py,agents/**/agent.py
description: Squad Mode multi-agent orchestration patterns and best practices
---

# ðŸŽ­ Squad Mode Multi-Agent Orchestration

## ðŸ—ï¸ Squad Mode Architecture

Squad Mode enables multi-agent collaboration where a main agent coordinates specialist sub-agents to provide comprehensive solutions.

### Key Components

**Main Agent** ([agents/ad-agency-pm/agent.py](mdc:agents/ad-agency-pm/agent.py)):
- Orchestrates the entire squad
- Manages delegation and synthesis
- Handles context sharing across agents
- Provides unified interface to user

**Sub-Agents** (in `sub-agents/` directory):
- Specialist agents with domain expertise
- Independent configuration and tools
- Focused on specific aspects of the problem
- Can be run individually or as part of squad

## ðŸŽ¯ Squad Mode Implementation Pattern

### Main Agent Squad Mode Setup

```python
class MainAgent(InteractiveAgent):
    def __init__(self, config_dir: Optional[Path] = None, squad_mode: bool = False):
        super().__init__(config_dir)
        self.squad_mode = squad_mode
        self.squad_agents = {}
        
        if squad_mode:
            self._initialize_squad()
    
    def _initialize_squad(self) -> None:
        """Initialize squad mode with sub-agents."""
        if not self.squad_mode:
            return
            
        self.squad_agents = {}
        sub_agents_dir = self.config_dir / "sub-agents"
        
        if not sub_agents_dir.exists():
            self.logger.warning("Sub-agents directory not found")
            return
        
        for agent_dir in sub_agents_dir.iterdir():
            if agent_dir.is_dir():
                try:
                    # Dynamic module loading for hyphenated directory names
                    import importlib.util
                    import sys
                    
                    agent_file = agent_dir / "agent.py"
                    module_name = agent_dir.name.replace("-", "_")
                    
                    spec = importlib.util.spec_from_file_location(module_name, agent_file)
                    module = importlib.util.module_from_spec(spec)
                    sys.modules[module_name] = module
                    spec.loader.exec_module(module)
                    
                    # Initialize agent
                    agent_class_name = f"{agent_dir.name.replace('-', '').title()}Agent"
                    agent_class = getattr(module, agent_class_name)
                    agent_instance = agent_class(agent_dir)
                    
                    self.squad_agents[agent_dir.name] = agent_instance
                    self.logger.info(f"Loaded sub-agent: {agent_dir.name}")
                    
                except Exception as e:
                    self.logger.error(f"Failed to load sub-agent {agent_dir.name}: {e}")
```

### Sub-Agent Structure Pattern

**Sub-agent directory structure:**
```
sub-agents/
â”œâ”€â”€ account-manager/
â”‚   â”œâ”€â”€ agent.py
â”‚   â””â”€â”€ config.yaml
â”œâ”€â”€ creative-director/
â”‚   â”œâ”€â”€ agent.py
â”‚   â””â”€â”€ config.yaml
â””â”€â”€ art-director/
    â”œâ”€â”€ agent.py
    â””â”€â”€ config.yaml
```

**Sub-agent implementation:**
```python
from shared.agents import InteractiveAgent
from claude_agent_sdk import tool
from typing import Dict, Any, List

class AccountManagerAgent(InteractiveAgent):
    def __init__(self, config_dir: Optional[Path] = None):
        super().__init__(config_dir)
        self.logger.info("Account Manager Agent initialized")
    
    def get_custom_tools(self) -> List[Any]:
        return [
            self.analyze_brief,
            self.extract_requirements,
            self.client_communication
        ]
    
    @tool("analyze_brief", "Analyzes client brief for requirements", {
        "brief_content": "str",
        "client_name": "str",
        "project_name": "str"
    })
    async def analyze_brief(self, args: Dict[str, Any]) -> Dict[str, Any]:
        # Implementation here
        pass
```

## ðŸ”§ Delegation Tools

### Individual Delegation

```python
@tool("delegate_to_account_manager", "Delegate task to Account Manager", {
    "task": "str",
    "context": "str"
})
async def delegate_to_account_manager(self, args: Dict[str, Any]) -> Dict[str, Any]:
    """Delegate task to Account Manager specialist."""
    return await self._delegate_to_specialist("account-manager", args.get("task", ""), args.get("context", ""))
```

### Parallel Squad Analysis

```python
@tool("run_creative_squad_review", "Run parallel analysis with creative squad", {
    "task": "str",
    "context": "str"
})
async def run_creative_squad_review(self, args: Dict[str, Any]) -> Dict[str, Any]:
    """Run parallel analysis with multiple creative specialists."""
    if not self.squad_mode:
        return {"content": [{"type": "text", "text": "Squad mode not enabled"}]}
    
    task = args.get("task", "")
    context = args.get("context", "")
    
    # Define which agents to include in creative review
    creative_agents = ["creative-director", "art-director", "copywriter"]
    available_agents = [name for name in creative_agents if name in self.squad_agents]
    
    if not available_agents:
        return {"content": [{"type": "text", "text": "No creative agents available"}]}
    
    try:
        # Run parallel analysis
        results = await self._parallel_analysis(available_agents, task, context)
        
        # Synthesize results
        synthesis = await self._synthesize_results(results, context)
        
        return {"content": [{"type": "text", "text": synthesis}]}
        
    except Exception as e:
        error_msg = f"Squad review failed: {str(e)}"
        self.logger.error(error_msg)
        return {"content": [{"type": "text", "text": error_msg}]}
```

## ðŸ”„ Workflow Orchestration

### Parallel Analysis Pattern

```python
async def _parallel_analysis(self, agent_names: List[str], task: str, context: str) -> Dict[str, str]:
    """Run analysis in parallel across multiple agents."""
    import asyncio
    
    async def analyze_with_agent(agent_name: str) -> tuple[str, str]:
        try:
            agent = self.squad_agents[agent_name]
            # Use the agent's query method for analysis
            result = ""
            async for message in agent.query(f"Task: {task}\nContext: {context}"):
                if hasattr(message, 'content') and message.content:
                    for block in message.content:
                        if hasattr(block, 'text'):
                            result += block.text
            
            return agent_name, result
        except Exception as e:
            self.logger.error(f"Error in {agent_name}: {e}")
            return agent_name, f"Error: {str(e)}"
    
    # Run all agents in parallel
    tasks = [analyze_with_agent(name) for name in agent_names]
    results = await asyncio.gather(*tasks, return_exceptions=True)
    
    # Process results
    analysis_results = {}
    for result in results:
        if isinstance(result, tuple):
            agent_name, analysis = result
            analysis_results[agent_name] = analysis
        else:
            self.logger.error(f"Unexpected result type: {type(result)}")
    
    return analysis_results
```

### Synthesis Pattern

```python
async def _synthesize_results(self, results: Dict[str, str], context: str) -> str:
    """Synthesize results from multiple agents into cohesive output."""
    if not results:
        return "No results to synthesize"
    
    # Use Creative Director for synthesis if available
    if "creative-director" in self.squad_agents:
        synthesis_prompt = f"""
        Synthesize the following specialist analyses into a cohesive strategy:
        
        Context: {context}
        
        Specialist Results:
        """
        
        for agent_name, result in results.items():
            synthesis_prompt += f"\n{agent_name.replace('-', ' ').title()}: {result}\n"
        
        synthesis_prompt += """
        
        Provide a comprehensive synthesis that combines all insights into actionable recommendations.
        """
        
        try:
            synthesis_result = ""
            async for message in self.squad_agents["creative-director"].query(synthesis_prompt):
                if hasattr(message, 'content') and message.content:
                    for block in message.content:
                        if hasattr(block, 'text'):
                            synthesis_result += block.text
            
            return f"ðŸŽ¯ **Squad Synthesis** (Creative Director):\n{synthesis_result}"
            
        except Exception as e:
            self.logger.error(f"Synthesis failed: {e}")
            return self._fallback_synthesis(results)
    
    return self._fallback_synthesis(results)

def _fallback_synthesis(self, results: Dict[str, str]) -> str:
    """Fallback synthesis when Creative Director is not available."""
    synthesis = "ðŸŽ¯ **Squad Analysis Results**:\n\n"
    
    for agent_name, result in results.items():
        synthesis += f"**{agent_name.replace('-', ' ').title()}**:\n{result}\n\n"
    
    synthesis += "**Summary**: Combined insights from all specialists provide comprehensive coverage of the task."
    return synthesis
```

## ðŸŽ¯ Context Sharing

### Automatic Context Propagation

```python
async def _delegate_to_specialist(self, specialist: str, task: str, context: str) -> str:
    """Delegate task to specific specialist with context."""
    if specialist not in self.squad_agents:
        return f"Specialist {specialist} not available"
    
    # Build context with project information
    full_context = f"""
    Project Context: {context}
    
    Task: {task}
    
    Please provide your specialist analysis and recommendations.
    """
    
    try:
        agent = self.squad_agents[specialist]
        result = ""
        
        async for message in agent.query(full_context):
            if hasattr(message, 'content') and message.content:
                for block in message.content:
                    if hasattr(block, 'text'):
                        result += block.text
        
        return f"**{specialist.replace('-', ' ').title()}**:\n{result}"
        
    except Exception as e:
        error_msg = f"Delegation to {specialist} failed: {str(e)}"
        self.logger.error(error_msg)
        return error_msg
```

## ðŸš€ Squad Mode Configuration

### Main Agent Config

```yaml
# config.yaml for main agent
name: Ad Agency Project Manager
description: AI Project Manager with Squad Mode capabilities
version: 0.1.0
model: claude-3-5-sonnet-20240620
allowed_tools:
  - mcp__ad_agency_pm_tools__create_client
  - mcp__ad_agency_pm_tools__delegate_to_account_manager
  - mcp__ad_agency_pm_tools__run_creative_squad_review
system_prompt: |
  You are an AI Project Manager with Squad Mode capabilities.
  You can delegate tasks to specialist agents or run parallel squad analysis.
squad_mode: true
```

### Sub-Agent Config

```yaml
# sub-agents/account-manager/config.yaml
name: Account Manager Agent
description: Specialist for client brief analysis and communication
version: 0.1.0
model: claude-3-5-sonnet-20240620
allowed_tools:
  - mcp__account_manager_tools__analyze_brief
  - mcp__account_manager_tools__extract_requirements
system_prompt: |
  You are an AI Account Manager specializing in brief analysis and client communication.
  Focus on understanding client needs and extracting actionable requirements.
```

## ðŸ§ª Testing Squad Mode

### Squad Mode Testing Pattern

```python
async def test_squad_mode():
    """Test squad mode initialization and delegation."""
    config_dir = Path("agents/ad-agency-pm")
    agent = AdAgencyProjectManager(config_dir, squad_mode=True)
    
    # Test squad initialization
    assert agent.squad_mode == True
    assert len(agent.squad_agents) > 0
    
    # Test delegation tools
    tools = agent.get_custom_tools()
    delegation_tools = [tool for tool in tools if 'delegate' in tool.name]
    assert len(delegation_tools) > 0
    
    # Test parallel analysis
    results = await agent._parallel_analysis(
        ["creative-director", "art-director"], 
        "Create a brand identity", 
        "Luxury hotel brand"
    )
    assert len(results) > 0
```

## ðŸ”’ Best Practices

### Error Handling

```python
async def _safe_delegation(self, specialist: str, task: str, context: str) -> str:
    """Safely delegate with comprehensive error handling."""
    try:
        if not self.squad_mode:
            return "Squad mode not enabled"
        
        if specialist not in self.squad_agents:
            return f"Specialist {specialist} not available"
        
        if not task.strip():
            return "Task cannot be empty"
        
        return await self._delegate_to_specialist(specialist, task, context)
        
    except Exception as e:
        error_msg = f"Delegation error: {str(e)}"
        self.logger.error(error_msg)
        return error_msg
```

### Performance Optimization

```python
async def _optimized_parallel_analysis(self, agent_names: List[str], task: str, context: str) -> Dict[str, str]:
    """Optimized parallel analysis with timeout and error handling."""
    import asyncio
    
    async def analyze_with_timeout(agent_name: str) -> tuple[str, str]:
        try:
            # Set timeout for individual agent analysis
            agent = self.squad_agents[agent_name]
            result = await asyncio.wait_for(
                self._get_agent_analysis(agent, task, context),
                timeout=30.0  # 30 second timeout
            )
            return agent_name, result
        except asyncio.TimeoutError:
            return agent_name, f"Analysis timeout for {agent_name}"
        except Exception as e:
            return agent_name, f"Error in {agent_name}: {str(e)}"
    
    # Run with overall timeout
    try:
        tasks = [analyze_with_timeout(name) for name in agent_names]
        results = await asyncio.wait_for(
            asyncio.gather(*tasks, return_exceptions=True),
            timeout=60.0  # 60 second overall timeout
        )
        
        return {name: result for name, result in results if isinstance(result, tuple)}
        
    except asyncio.TimeoutError:
        self.logger.error("Overall squad analysis timeout")
        return {"error": "Squad analysis timeout"}
```