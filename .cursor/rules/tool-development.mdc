---
description: Custom tool development patterns and best practices for Claude agents
---

# Custom Tool Development Patterns

## Tool Structure and Organization

### File Organization
```
agents/
├── agent-name/
│   ├── agent.py              # Main agent implementation
│   ├── config.yaml           # Agent configuration
│   ├── requirements.txt      # Dependencies
│   ├── README.md            # Documentation
│   ├── tools/               # Custom tools directory
│   │   ├── __init__.py
│   │   ├── project_tools.py # Project-related tools
│   │   ├── client_tools.py  # Client-related tools
│   │   └── squad_tools.py   # Squad mode tools
│   └── sub-agents/          # For squad mode
│       └── specialist-name/
│           ├── agent.py
│           └── config.yaml
```

### Tool Definition Pattern
```python
from claude_agent_sdk import tool
from typing import Dict, Any, List, Optional
import json
from pathlib import Path

@tool("tool_name", "Tool description", {
    "param1": "str",
    "param2": "int",
    "param3": "bool"
})
async def my_tool(self, args: Dict[str, Any]) -> Dict[str, Any]:
    """
    Tool implementation with proper error handling.
    
    Args:
        args: Dictionary containing tool arguments
        
    Returns:
        Dictionary with tool result
    """
    try:
        # Validate required parameters
        param1 = args.get("param1", "")
        param2 = args.get("param2", 0)
        param3 = args.get("param3", False)
        
        if not param1:
            return {
                "content": [{
                    "type": "text", 
                    "text": "Error: param1 is required"
                }]
            }
        
        # Tool logic here
        result = f"Processed {param1} with {param2}"
        
        # Log successful execution
        self.logger.info(f"Tool executed successfully: {result}")
        
        return {
            "content": [{
                "type": "text", 
                "text": result
            }]
        }
        
    except ValueError as e:
        error_msg = f"Validation error: {str(e)}"
        self.logger.warning(error_msg)
        return {
            "content": [{
                "type": "text", 
                "text": error_msg
            }]
        }
        
    except Exception as e:
        error_msg = f"Unexpected error: {str(e)}"
        self.logger.error(error_msg)
        return {
            "content": [{
                "type": "text", 
                "text": "An error occurred. Please try again."
            }]
        }
```

## Data Management Tools

### CRUD Operations Pattern
```python
@tool("create_project", "Create a new project", {
    "name": "str",
    "description": "str", 
    "client_id": "str",
    "budget": "int",
    "deadline": "str",
    "priority": "str",
    "team_members": "list"
})
async def create_project(self, args: Dict[str, Any]) -> Dict[str, Any]:
    """Create a new project."""
    try:
        # Validate input
        name = args.get("name", "").strip()
        if not name:
            return {"content": [{"type": "text", "text": "Error: Project name is required"}]}
        
        # Create project object
        project = {
            "id": f"project-{int(time.time() * 1000)}",
            "name": name,
            "description": args.get("description", ""),
            "client_id": args.get("client_id", ""),
            "budget": args.get("budget", 0),
            "deadline": args.get("deadline", ""),
            "priority": args.get("priority", "Medium"),
            "team_members": args.get("team_members", []),
            "status": "Not Started",
            "progress": 0,
            "created_at": datetime.now().isoformat(),
            "updated_at": datetime.now().isoformat()
        }
        
        # Save to data store
        projects = self._load_projects()
        projects.append(project)
        self._save_projects(projects)
        
        self.logger.info(f"Created project: {project['name']}")
        
        return {
            "content": [{
                "type": "text",
                "text": f"Successfully created project '{project['name']}' with ID {project['id']}"
            }]
        }
        
    except Exception as e:
        error_msg = f"Failed to create project: {str(e)}"
        self.logger.error(error_msg)
        return {"content": [{"type": "text", "text": error_msg}]}

def _load_projects(self) -> List[Dict[str, Any]]:
    """Load projects from data file."""
    projects_file = self.data_dir / "projects.json"
    if projects_file.exists():
        with open(projects_file, 'r') as f:
            return json.load(f)
    return []

def _save_projects(self, projects: List[Dict[str, Any]]) -> None:
    """Save projects to data file."""
    self.data_dir.mkdir(exist_ok=True)
    projects_file = self.data_dir / "projects.json"
    with open(projects_file, 'w') as f:
        json.dump(projects, f, indent=2)
    self.logger.info(f"Saved {len(projects)} projects to {projects_file}")
```

### Search and Filter Tools
```python
@tool("search_projects", "Search projects by criteria", {
    "query": "str",
    "status": "str",
    "priority": "str",
    "client_id": "str"
})
async def search_projects(self, args: Dict[str, Any]) -> Dict[str, Any]:
    """Search projects based on criteria."""
    try:
        projects = self._load_projects()
        
        # Apply filters
        filtered_projects = projects
        
        query = args.get("query", "").lower()
        if query:
            filtered_projects = [
                p for p in filtered_projects 
                if query in p.get("name", "").lower() or 
                   query in p.get("description", "").lower()
            ]
        
        status = args.get("status")
        if status:
            filtered_projects = [
                p for p in filtered_projects 
                if p.get("status") == status
            ]
        
        priority = args.get("priority")
        if priority:
            filtered_projects = [
                p for p in filtered_projects 
                if p.get("priority") == priority
            ]
        
        client_id = args.get("client_id")
        if client_id:
            filtered_projects = [
                p for p in filtered_projects 
                if p.get("client_id") == client_id
            ]
        
        # Format results
        if not filtered_projects:
            return {
                "content": [{
                    "type": "text",
                    "text": "No projects found matching the criteria."
                }]
            }
        
        results = []
        for project in filtered_projects[:10]:  # Limit to 10 results
            results.append(f"- {project['name']} ({project['status']}) - ${project['budget']:,}")
        
        return {
            "content": [{
                "type": "text",
                "text": f"Found {len(filtered_projects)} projects:\n" + "\n".join(results)
            }]
        }
        
    except Exception as e:
        error_msg = f"Search failed: {str(e)}"
        self.logger.error(error_msg)
        return {"content": [{"type": "text", "text": error_msg}]}
```

## Squad Mode Tools

### Delegation Tools
```python
@tool("delegate_to_specialist", "Delegate task to a specialist agent", {
    "specialist": "str",
    "task": "str",
    "context": "str"
})
async def delegate_to_specialist(self, args: Dict[str, Any]) -> Dict[str, Any]:
    """Delegate task to specific specialist agent."""
    if not self.squad_mode:
        return {
            "content": [{
                "type": "text", 
                "text": "Squad mode is not enabled. Enable it first to use delegation."
            }]
        }
    
    try:
        specialist = args.get("specialist", "")
        task = args.get("task", "")
        context = args.get("context", "")
        
        if specialist not in self.squad_agents:
            available = ", ".join(self.squad_agents.keys())
            return {
                "content": [{
                    "type": "text",
                    "text": f"Specialist '{specialist}' not available. Available: {available}"
                }]
            }
        
        # Execute delegation
        result = await self._delegate_to_specialist(specialist, task, context)
        
        return {
            "content": [{
                "type": "text",
                "text": f"Delegated to {specialist}:\n{result}"
            }]
        }
        
    except Exception as e:
        error_msg = f"Delegation failed: {str(e)}"
        self.logger.error(error_msg)
        return {"content": [{"type": "text", "text": error_msg}]}

@tool("run_squad_review", "Run parallel analysis with all specialists", {
    "review_scope": "str",
    "context": "str"
})
async def run_squad_review(self, args: Dict[str, Any]) -> Dict[str, Any]:
    """Run parallel analysis with multiple specialists."""
    if not self.squad_mode:
        return {
            "content": [{
                "type": "text",
                "text": "Squad mode is not enabled. Enable it first to run squad reviews."
            }]
        }
    
    try:
        review_scope = args.get("review_scope", "")
        context = args.get("context", "")
        
        if not review_scope:
            return {
                "content": [{
                    "type": "text",
                    "text": "Review scope is required."
                }]
            }
        
        # Run parallel analysis
        results = await self._parallel_analysis(
            list(self.squad_agents.keys()), 
            review_scope, 
            context
        )
        
        # Generate synthesis
        synthesis = await self._synthesize_results(results, context)
        
        return {
            "content": [{
                "type": "text",
                "text": f"Squad Review Results:\n\n{synthesis}"
            }]
        }
        
    except Exception as e:
        error_msg = f"Squad review failed: {str(e)}"
        self.logger.error(error_msg)
        return {"content": [{"type": "text", "text": error_msg}]}
```

## Utility Tools

### File Operations
```python
@tool("export_data", "Export data to file", {
    "data_type": "str",
    "format": "str",
    "filename": "str"
})
async def export_data(self, args: Dict[str, Any]) -> Dict[str, Any]:
    """Export data to specified format."""
    try:
        data_type = args.get("data_type", "")
        format_type = args.get("format", "json")
        filename = args.get("filename", f"export_{data_type}.{format_type}")
        
        # Load data
        if data_type == "projects":
            data = self._load_projects()
        elif data_type == "clients":
            data = self._load_clients()
        else:
            return {
                "content": [{
                    "type": "text",
                    "text": f"Unknown data type: {data_type}"
                }]
            }
        
        # Export file
        export_file = self.data_dir / filename
        
        if format_type == "json":
            with open(export_file, 'w') as f:
                json.dump(data, f, indent=2)
        elif format_type == "csv":
            import csv
            if data:
                with open(export_file, 'w', newline='') as f:
                    writer = csv.DictWriter(f, fieldnames=data[0].keys())
                    writer.writeheader()
                    writer.writerows(data)
        else:
            return {
                "content": [{
                    "type": "text",
                    "text": f"Unsupported format: {format_type}"
                }]
            }
        
        self.logger.info(f"Exported {len(data)} {data_type} to {export_file}")
        
        return {
            "content": [{
                "type": "text",
                "text": f"Successfully exported {len(data)} {data_type} to {filename}"
            }]
        }
        
    except Exception as e:
        error_msg = f"Export failed: {str(e)}"
        self.logger.error(error_msg)
        return {"content": [{"type": "text", "text": error_msg}]}
```

### Validation and Sanitization
```python
def _validate_input(self, data: Any, expected_type: type) -> bool:
    """Validate input data type and content."""
    if not isinstance(data, expected_type):
        return False
    
    if isinstance(data, str):
        # Sanitize string input
        sanitized = data.strip()
        return len(sanitized) > 0 and len(sanitized) < 10000
    
    return True

def _sanitize_input(self, input_data: str) -> str:
    """Sanitize user input to prevent injection attacks."""
    dangerous_chars = ['<', '>', '"', "'", '&', ';', '|', '`', '$']
    sanitized = input_data
    
    for char in dangerous_chars:
        sanitized = sanitized.replace(char, '')
    
    return sanitized.strip()[:10000]  # Limit length
```

## Error Handling Patterns

### Comprehensive Error Handling
```python
async def robust_tool_execution(self, args: Dict[str, Any]) -> Dict[str, Any]:
    """Template for robust tool execution."""
    try:
        # Input validation
        if not self._validate_input(args, dict):
            return {
                "content": [{
                    "type": "text",
                    "text": "Invalid input format"
                }]
            }
        
        # Parameter extraction with defaults
        param1 = args.get("param1", "")
        param2 = args.get("param2", 0)
        
        # Business logic validation
        if not param1:
            return {
                "content": [{
                    "type": "text",
                    "text": "Required parameter 'param1' is missing"
                }]
            }
        
        # Execute core logic
        result = await self._core_logic(param1, param2)
        
        # Log success
        self.logger.info(f"Tool executed successfully with result: {result}")
        
        return {
            "content": [{
                "type": "text",
                "text": result
            }]
        }
        
    except ValueError as e:
        # Handle validation errors
        error_msg = f"Validation error: {str(e)}"
        self.logger.warning(error_msg)
        return {
            "content": [{
                "type": "text",
                "text": error_msg
            }]
        }
        
    except PermissionError as e:
        # Handle permission errors
        error_msg = f"Permission denied: {str(e)}"
        self.logger.warning(error_msg)
        return {
            "content": [{
                "type": "text",
                "text": "You don't have permission to perform this action"
            }]
        }
        
    except Exception as e:
        # Handle unexpected errors
        error_msg = f"Unexpected error: {str(e)}"
        self.logger.error(error_msg)
        return {
            "content": [{
                "type": "text",
                "text": "An unexpected error occurred. Please try again."
            }]
        }
```

## Tool Registration

### Agent Integration
```python
class MyAgent(InteractiveAgent):
    def __init__(self, config_dir: Optional[Path] = None, squad_mode: bool = False):
        super().__init__(config_dir)
        self.squad_mode = squad_mode
        self.logger.info("MyAgent initialized")
    
    def get_custom_tools(self) -> List[Any]:
        """Return list of custom tools for this agent."""
        tools = [
            # Core tools
            self.create_project,
            self.update_project,
            self.delete_project,
            self.search_projects,
            self.create_client,
            self.update_client,
            self.export_data,
        ]
        
        # Add squad mode tools if enabled
        if self.squad_mode:
            tools.extend([
                self.delegate_to_specialist,
                self.run_squad_review,
                self.get_squad_status,
            ])
        
        return tools
```

## Testing Tools

### Tool Testing Pattern
```python
import pytest
from unittest.mock import AsyncMock, patch

@pytest.mark.asyncio
async def test_create_project_tool():
    """Test project creation tool."""
    agent = MyAgent()
    
    # Test successful creation
    args = {
        "name": "Test Project",
        "description": "Test description",
        "client_id": "client-1",
        "budget": 50000,
        "deadline": "2024-06-15",
        "priority": "High",
        "team_members": ["user-1", "user-2"]
    }
    
    result = await agent.create_project(args)
    
    assert "content" in result
    assert "Successfully created project" in result["content"][0]["text"]
    
    # Test validation error
    args_invalid = {"name": ""}  # Missing required name
    result = await agent.create_project(args_invalid)
    
    assert "Error" in result["content"][0]["text"]
```

## Documentation Patterns

### Tool Documentation
```python
@tool("complex_tool", "Complex tool with multiple parameters", {
    "required_param": "str",
    "optional_param": "int", 
    "list_param": "list",
    "bool_param": "bool"
})
async def complex_tool(self, args: Dict[str, Any]) -> Dict[str, Any]:
    """
    Complex tool that demonstrates various parameter types and validation.
    
    This tool performs complex operations with multiple parameter types.
    
    Args:
        args: Dictionary containing:
            required_param (str): Required string parameter with description
            optional_param (int, optional): Optional integer parameter (default: 0)
            list_param (list, optional): Optional list parameter (default: [])
            bool_param (bool, optional): Optional boolean parameter (default: False)
    
    Returns:
        Dict containing:
            content: List with text content describing the operation result
    
    Raises:
        ValueError: If required parameters are missing or invalid
        RuntimeError: If the operation fails due to system issues
    
    Example:
        >>> args = {
        ...     "required_param": "test",
        ...     "optional_param": 42,
        ...     "list_param": ["item1", "item2"],
        ...     "bool_param": True
        ... }
        >>> result = await complex_tool(args)
        >>> print(result["content"][0]["text"])
        "Operation completed successfully"
    """
    # Implementation here...
```